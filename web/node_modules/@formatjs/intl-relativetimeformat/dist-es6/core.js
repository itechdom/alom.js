import { VALID_UNITS } from './types';
import { findSupportedLocale, toObject, getOption, getParentLocaleHierarchy, supportedLocalesOf, } from '@formatjs/intl-utils';
/**
 * Find the correct field data in our CLDR data
 * Also merge with parent data since our CLDR is very packed
 * @param locale locale
 */
function findFields(locale) {
    const localeData = RelativeTimeFormat.__localeData__;
    const parentHierarchy = getParentLocaleHierarchy(locale);
    const dataToMerge = [locale, ...parentHierarchy]
        .map(l => localeData[l.toLowerCase()])
        .filter(Boolean);
    if (!dataToMerge.length) {
        throw new Error(`Locale data added to RelativeTimeFormat is missing 'fields' for "${locale}"`);
    }
    dataToMerge.reverse();
    return dataToMerge.reduce((all, d) => (Object.assign(Object.assign({}, all), d.fields)), {});
}
function findFieldData(fields, unit, style) {
    if (style == 'long') {
        return fields[unit];
    }
    if (style == 'narrow') {
        return (fields[`${unit}-narrow`] ||
            fields[`${unit}-short`]);
    }
    return fields[`${unit}-short`];
}
function objectIs(x, y) {
    if (Object.is) {
        return Object.is(x, y);
    }
    // SameValue algorithm
    if (x === y) {
        // Steps 1-5, 7-10
        // Steps 6.b-6.e: +0 != -0
        return x !== 0 || 1 / x === 1 / y;
    }
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
}
function resolvePastOrFuture(value) {
    return objectIs(value, -0)
        ? 'past'
        : objectIs(value, +0)
            ? 'future'
            : value < 0
                ? 'past'
                : 'future';
}
function validateInstance(instance, method) {
    if (!(instance instanceof RelativeTimeFormat)) {
        throw new TypeError(`Method Intl.RelativeTimeFormat.prototype.${method} called on incompatible receiver ${String(instance)}`);
    }
}
function validateUnit(unit) {
    // `unit + ''` to guard against `Symbol()`
    if (!~VALID_UNITS.indexOf(unit + '')) {
        throw new RangeError(`Invalid unit argument for format() '${String(unit)}'`);
    }
    const resolvedUnit = (unit[unit.length - 1] === 's'
        ? unit.slice(0, unit.length - 1)
        : unit);
    return resolvedUnit;
}
function validateValue(value, method = 'format') {
    const parsedValue = typeof value === 'string' ? new Number(value).valueOf() : value;
    if (!isFinite(parsedValue)) {
        throw new RangeError(`Value need to be finite number for Intl.RelativeTimeFormat.prototype.${method}()`);
    }
    return parsedValue;
}
function isString(s) {
    return !!s;
}
const DEFAULT_LOCALE = new Intl.NumberFormat().resolvedOptions().locale;
export default class RelativeTimeFormat {
    constructor(locales, options) {
        // test262/test/intl402/RelativeTimeFormat/constructor/constructor/newtarget-undefined.js
        // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
        const newTarget = this && this instanceof RelativeTimeFormat ? this.constructor : void 0;
        if (!newTarget) {
            throw new TypeError("Intl.RelativeTimeFormat must be called with 'new'");
        }
        const opts = options === undefined ? Object.create(null) : toObject(options);
        const localesToLookup = locales === undefined
            ? [DEFAULT_LOCALE]
            : [...Intl.NumberFormat.supportedLocalesOf(locales), DEFAULT_LOCALE];
        const resolvedLocale = findSupportedLocale(localesToLookup, RelativeTimeFormat.__localeData__);
        if (!resolvedLocale) {
            throw new Error(`No locale data has been added to IntlRelativeTimeFormat for: ${localesToLookup.join(', ')}`);
        }
        this._fields = findFields(resolvedLocale);
        this._localeMatcher = getOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
        this._style = getOption(opts, 'style', 'string', ['long', 'narrow', 'short'], 'long');
        this._numeric = getOption(opts, 'numeric', 'string', ['always', 'auto'], 'always');
        this._nf = new Intl.NumberFormat(locales);
        this._pl = new Intl.PluralRules(locales);
        this._numberingSystem = this._nf.resolvedOptions().numberingSystem;
    }
    format(value, unit) {
        validateInstance(this, 'format');
        const resolvedUnit = validateUnit(unit);
        const parsedValue = validateValue(value);
        const { _style: style, _numeric: numeric } = this;
        const fieldData = findFieldData(this._fields, resolvedUnit, style);
        if (!fieldData) {
            throw new Error(`Unsupported unit ${unit}`);
        }
        const { relative, relativeTime } = fieldData;
        let result = '';
        // We got a match for things like yesterday
        if (numeric == 'auto' &&
            (result = relative[String(parsedValue)] || '')) {
            return result;
        }
        const selector = this._pl.select(parsedValue);
        const futureOrPastData = relativeTime[resolvePastOrFuture(parsedValue)];
        const msg = futureOrPastData[selector] || futureOrPastData.other;
        return msg.replace(/\{0\}/, this._nf.format(Math.abs(parsedValue)));
    }
    formatToParts(value, unit) {
        validateInstance(this, 'format');
        const resolvedUnit = validateUnit(unit);
        const parsedValue = validateValue(value, 'formatToParts');
        const { _style: style, _numeric: numeric } = this;
        const fieldData = findFieldData(this._fields, resolvedUnit, style);
        if (!fieldData) {
            throw new Error(`Unsupported unit ${unit}`);
        }
        const { relative, relativeTime } = fieldData;
        let result = '';
        // We got a match for things like yesterday
        if (numeric == 'auto' &&
            (result = relative[String(parsedValue)] || '')) {
            return [
                {
                    type: 'literal',
                    value: result,
                },
            ];
        }
        const selector = this._pl.select(parsedValue);
        const futureOrPastData = relativeTime[resolvePastOrFuture(parsedValue)];
        const msg = futureOrPastData[selector] || futureOrPastData.other;
        const valueParts = this._nf
            .formatToParts(Math.abs(parsedValue))
            .map(p => (Object.assign(Object.assign({}, p), { unit: resolvedUnit })));
        return msg
            .split(/(\{0\})/)
            .filter(isString)
            .reduce((parts, str) => [
            ...parts,
            ...(str === '{0}'
                ? valueParts
                : [{ type: 'literal', value: str }]),
        ], []);
    }
    resolvedOptions() {
        validateInstance(this, 'resolvedOptions');
        // test262/test/intl402/RelativeTimeFormat/prototype/resolvedOptions/type.js
        const opts = Object.create(Object.prototype);
        Object.defineProperties(opts, {
            locale: {
                value: this._nf.resolvedOptions().locale,
                writable: true,
                enumerable: true,
                configurable: true,
            },
            style: {
                value: this._style.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
            numeric: {
                value: this._numeric.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
            numberingSystem: {
                value: this._numberingSystem.valueOf(),
                writable: true,
                enumerable: true,
                configurable: true,
            },
        });
        return opts;
    }
    static supportedLocalesOf(locales, opts) {
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/options-toobject.js
        let localeMatcher = 'best fit';
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/options-null.js
        if (opts === null) {
            throw new TypeError('opts cannot be null');
        }
        if (opts) {
            localeMatcher = getOption(opts, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
        }
        // test262/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/result-type.js
        return supportedLocalesOf(Intl.NumberFormat.supportedLocalesOf(locales, { localeMatcher }), RelativeTimeFormat.__localeData__);
    }
    static __addLocaleData(...data) {
        for (const datum of data) {
            if (!(datum && datum.locale)) {
                throw new Error('Locale data provided to RelativeTimeFormat is missing a ' +
                    '`locale` property value');
            }
            RelativeTimeFormat.__localeData__[datum.locale.toLowerCase()] = datum;
        }
    }
}
RelativeTimeFormat.__localeData__ = {};
RelativeTimeFormat.polyfilled = true;
try {
    // IE11 does not have Symbol
    if (typeof Symbol !== 'undefined') {
        Object.defineProperty(RelativeTimeFormat.prototype, Symbol.toStringTag, {
            value: 'Intl.RelativeTimeFormat',
            writable: false,
            enumerable: false,
            configurable: true,
        });
    }
    // https://github.com/tc39/test262/blob/master/test/intl402/RelativeTimeFormat/constructor/length.js
    Object.defineProperty(RelativeTimeFormat.prototype.constructor, 'length', {
        value: 0,
        writable: false,
        enumerable: false,
        configurable: true,
    });
    // https://github.com/tc39/test262/blob/master/test/intl402/RelativeTimeFormat/constructor/supportedLocalesOf/length.js
    Object.defineProperty(RelativeTimeFormat.supportedLocalesOf, 'length', {
        value: 1,
        writable: false,
        enumerable: false,
        configurable: true,
    });
}
catch (e) {
    // Meta fix so we're test262-compliant, not important
}
